package io.perftest.engine;

import static us.abstracta.jmeter.javadsl.JmeterDsl.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.abstracta.jmeter.javadsl.core.listeners.HtmlReporter;

import io.perftest.components.graphql.GraphQLComponent;
import io.perftest.components.http.HttpComponent;
import io.perftest.components.jdbc.JdbcComponent;
import io.perftest.components.soap.SoapComponent;
import io.perftest.components.xml.XmlComponent;
import io.perftest.entities.request.GraphQLRequestEntity;
import io.perftest.entities.request.HttpRequestEntity;
import io.perftest.entities.request.JdbcRequestEntity;
import io.perftest.entities.request.RequestEntity;
import io.perftest.entities.request.SoapRequestEntity;
import io.perftest.entities.request.XmlRequestEntity;
import io.perftest.exception.ErrorCode;
import io.perftest.exception.Result;
import io.perftest.exception.TestExecutionException;
import io.perftest.systems.TestSystem;
import io.perftest.util.JMeterLogConfiguration;
import us.abstracta.jmeter.javadsl.core.DslTestPlan;
import us.abstracta.jmeter.javadsl.core.TestPlanStats;
import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup;
import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup.ThreadGroupChild;

/**
 * The TestEngine is the main orchestrator for performance test execution.
 * 
 * <p>This class provides a high-level API for configuring and executing performance tests
 * using the JMeter DSL. It serves as the integration point between the ECS architecture
 * and the underlying JMeter test execution engine.</p>
 * 
 * <p>TestEngine is responsible for:</p>
 * <ul>
 *     <li>Managing test configuration (threads, iterations, ramp-up time)</li>
 *     <li>Registering components for different protocol handlers</li>
 *     <li>Coordinating the request processing pipeline</li>
 *     <li>Executing the test and collecting results</li>
 *     <li>Managing test result files and directories</li>
 * </ul>
 * 
 * <p>Example usage:</p>
 * <pre>{@code
 * TestEngine engine = new TestEngine();
 * engine.setThreads(10)
 *       .setIterations(100)
 *       .setRampUp(Duration.ofSeconds(30));
 *       
 * HttpRequestEntity request = new HttpRequestEntity()
 *       .setUrl("https://example.com/api")
 *       .setMethod("GET");
 *       
 * engine.addRequest(request);
 * TestPlanStats stats = engine.runTest();
 * }</pre>
 */
public class TestEngine {
    private static final Logger logger = LoggerFactory.getLogger(TestEngine.class);
    
    private final TestSystem testSystem;
    private final List<RequestEntity> requests;
    private final Map<String, Path> resultPaths;
    private final Map<String, Path> htmlReportPaths;
    
    private int threads = 1;
    private int iterations = 1;
    private Duration rampUp = Duration.ofSeconds(0);
    private boolean initialized = false;
    private String protocolName = "default";
    private String testPlanName = "Test Plan";
    
    // Modifiers for different request types
    private Consumer<HttpRequestEntity> httpModifier;
    private Consumer<GraphQLRequestEntity> graphqlModifier;
    private Consumer<XmlRequestEntity> xmlModifier;
    private Consumer<SoapRequestEntity> soapModifier;
    private Consumer<JdbcRequestEntity> jdbcModifier;
    
    /**
     * Creates a new TestEngine instance with default TestSystem.
     * 
     * <p>The constructor initializes a TestSystem and registers default components
     * for HTTP, GraphQL, XML, SOAP, and JDBC protocols.</p>
     */
    public TestEngine() {
        this(new TestSystem());
    }
    
    /**
     * Creates a new TestEngine instance with a provided TestSystem.
     * 
     * <p>This constructor allows for dependency injection of a TestSystem instance.
     * It will reuse the provided TestSystem without registering additional components.</p>
     * 
     * @param testSystem The TestSystem to use
     */
    public TestEngine(TestSystem testSystem) {
        this.testSystem = testSystem;
        this.requests = new ArrayList<>();
        this.resultPaths = new HashMap<>();
        this.htmlReportPaths = new HashMap<>();
        
        // Register default components if TestSystem is empty
        if (testSystem.getComponentCount() == 0) {
            registerDefaultComponents();
        }
    }
    
    /**
     * Registers the default components for various protocols.
     * 
     * <p>This method is called during TestEngine initialization to set up the
     * standard protocol handlers. It registers components for HTTP, GraphQL,
     * XML, SOAP, and JDBC protocols.</p>
     */
    private void registerDefaultComponents() {
        // Register HTTP component
        testSystem.addComponent(HttpRequestEntity.class, new HttpComponent());
        
        // Register GraphQL component
        testSystem.addComponent(GraphQLRequestEntity.class, new GraphQLComponent());
        
        // Register XML component
        testSystem.addComponent(XmlRequestEntity.class, new XmlComponent());
        
        // Register SOAP component
        testSystem.addComponent(SoapRequestEntity.class, new SoapComponent());
        
        // Register JDBC component
        testSystem.addComponent(JdbcRequestEntity.class, new JdbcComponent());
        
        initialized = true;
    }
    
    /**
     * Set the number of threads (virtual users) for the test.
     * 
     * <p>This sets the number of concurrent threads that will execute the test plan.
     * Each thread will execute the test iterations, simulating a virtual user.</p>
     * 
     * @param threads Number of threads (virtual users)
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setThreads(int threads) {
        this.threads = threads;
        return this;
    }
    
    /**
     * Get the number of threads configured for the test.
     * 
     * @return Number of threads (virtual users)
     */
    public int getThreads() {
        return threads;
    }
    
    /**
     * Set the number of iterations for the test.
     * 
     * <p>This sets the number of times each thread will execute the test samplers.
     * The total number of requests will be threads * iterations * number of samplers.</p>
     * 
     * @param iterations Number of iterations per thread
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setIterations(int iterations) {
        this.iterations = iterations;
        return this;
    }
    
    /**
     * Get the number of iterations configured for the test.
     * 
     * @return Number of iterations per thread
     */
    public int getIterations() {
        return iterations;
    }
    
    /**
     * Set the ramp-up period for the test.
     * 
     * <p>This sets the time period over which JMeter will start all threads.
     * For example, if you have 100 threads and a ramp-up period of 50 seconds,
     * then JMeter will take 50 seconds to start all 100 threads, with each thread
     * starting 0.5 seconds after the previous thread.</p>
     * 
     * @param rampUp The ramp-up period as a Duration
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setRampUp(Duration rampUp) {
        this.rampUp = rampUp;
        return this;
    }
    
    /**
     * Get the ramp-up period configured for the test.
     * 
     * @return The ramp-up period as a Duration
     */
    public Duration getRampUp() {
        return rampUp;
    }
    
    /**
     * Set the protocol name for reporting purposes.
     * 
     * <p>This name is used in log files and results directories to identify
     * the protocol being tested (e.g., "http", "graphql", "jdbc", etc.).</p>
     * 
     * @param protocolName The protocol name
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setProtocolName(String protocolName) {
        this.protocolName = protocolName;
        return this;
    }
    
    /**
     * Get the protocol name configured for reporting.
     * 
     * @return The protocol name
     */
    public String getProtocolName() {
        return protocolName;
    }
    
    /**
     * Set the test plan name.
     * 
     * <p>This name is used in JMeter reports to identify the test plan.
     * It's primarily for documentation purposes.</p>
     * 
     * @param testPlanName The test plan name
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setTestPlanName(String testPlanName) {
        this.testPlanName = testPlanName;
        return this;
    }
    
    /**
     * Get the test plan name.
     * 
     * @return The test plan name
     */
    public String getTestPlanName() {
        return testPlanName;
    }
    
    /**
     * Add a request to the test plan.
     * 
     * <p>The request will be processed by the appropriate component based on its type
     * when the test is executed.</p>
     * 
     * @param request The RequestEntity to add
     * @return This TestEngine instance for method chaining
     */
    public TestEngine addRequest(RequestEntity request) {
        requests.add(request);
        return this;
    }
    
    /**
     * Set a modifier function for HTTP requests.
     * 
     * <p>This modifier will be applied to each HttpRequestEntity before it's processed
     * by the HttpComponent. It can be used to add common headers, query parameters,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies HttpRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setHttpRequestModifier(Consumer<HttpRequestEntity> modifier) {
        this.httpModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for GraphQL requests.
     * 
     * <p>This modifier will be applied to each GraphQLRequestEntity before it's processed
     * by the GraphQLComponent. It can be used to add common headers, variables,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies GraphQLRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setGraphQLRequestModifier(Consumer<GraphQLRequestEntity> modifier) {
        this.graphqlModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for XML requests.
     * 
     * <p>This modifier will be applied to each XmlRequestEntity before it's processed
     * by the XmlComponent. It can be used to add common headers, XML attributes,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies XmlRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setXmlRequestModifier(Consumer<XmlRequestEntity> modifier) {
        this.xmlModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for SOAP requests.
     * 
     * <p>This modifier will be applied to each SoapRequestEntity before it's processed
     * by the SoapComponent. It can be used to add common headers, SOAP actions,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies SoapRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setSoapRequestModifier(Consumer<SoapRequestEntity> modifier) {
        this.soapModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for JDBC requests.
     * 
     * <p>This modifier will be applied to each JdbcRequestEntity before it's processed
     * by the JdbcComponent. It can be used to add common query parameters,
     * connection pool settings, or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies JdbcRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setJdbcRequestModifier(Consumer<JdbcRequestEntity> modifier) {
        this.jdbcModifier = modifier;
        return this;
    }
    
    /**
     * Run the test without additional configuration.
     * 
     * <p>This method is an alias for runTest() to maintain compatibility with 
     * older code. It simply delegates to the runTest() method.</p>
     * 
     * @return TestPlanStats containing the results of the test execution
     * @throws IOException If there's an error creating result directories
     * @throws TestExecutionException If an error occurs during test execution
     */
    public TestPlanStats run() throws IOException {
        return runTest();
    }
    
    /**
     * Execute the test plan with all configured requests and settings.
     * 
     * <p>This method processes all requests added to the TestEngine, generating
     * JMeter samplers, configuring the test execution, and running the test.</p>
     * 
     * <p>It handles setting up the result directories, configuring logging,
     * creating the JMeter test plan, and returning the test statistics.</p>
     * 
     * @return TestPlanStats containing the results of the test execution
     * @throws IOException If there's an error creating result directories
     * @throws TestExecutionException If an error occurs during test setup or execution
     */
    public TestPlanStats runTest() throws IOException {
        if (requests.isEmpty()) {
            throw new TestExecutionException(ErrorCode.TEST_EXECUTION_ERROR, "No requests added to test plan");
        }
        
        logger.info("Starting test execution with {} threads, {} iterations, {} ramp-up",
                threads, iterations, rampUp);
                
        // Configure JMeter logging for this specific test execution
        String testLogFile = JMeterLogConfiguration.configureLogging(protocolName);
        logger.info("JMeter logs will be written to: {}", testLogFile);
        
        // Create results directories
        ResultsDirectories resultDirs = createResultsDirectories(protocolName);
        Path jtlPath = resultDirs.jtlPath;
        Path htmlPath = resultDirs.htmlPath;
        logger.info("Test results will be written to: {}", jtlPath);
        logger.info("HTML reports will be generated at: {}", htmlPath);
        
        // Create thread group for the test with ThreadGroupChild[] samplers
        ThreadGroupChild[] samplers = generateSamplers();
        BaseThreadGroup threadGroup = threadGroup(threads, iterations, samplers);
        
        // Create the test plan with both JTL writer and HTML reporter
        DslTestPlan testPlan = testPlan(
                threadGroup, 
                jtlWriter(jtlPath.toString()),
                htmlReporter(htmlPath.toString())
        );
        
        try {
            // Run the test and return the statistics
            TestPlanStats stats = testPlan.run();
            logger.info("Test execution completed successfully");
            return stats;
        } catch (Exception e) {
            logger.error("Test execution failed", e);
            throw new TestExecutionException(ErrorCode.TEST_EXECUTION_ERROR, "Test execution failed", e);
        }
    }
    
    /**
     * Generates JMeter samplers for all requests in the test plan.
     * 
     * <p>This method processes each request entity using the appropriate component
     * registered with the TestSystem, applying any modifiers before processing.</p>
     * 
     * @return Array of JMeter samplers for the test plan
     */
    private ThreadGroupChild[] generateSamplers() {
        List<ThreadGroupChild> samplers = new ArrayList<>();
        
        for (RequestEntity request : requests) {
            // Apply the appropriate modifier based on request type
            if (request instanceof HttpRequestEntity && httpModifier != null) {
                httpModifier.accept((HttpRequestEntity) request);
            } else if (request instanceof GraphQLRequestEntity && graphqlModifier != null) {
                graphqlModifier.accept((GraphQLRequestEntity) request);
            } else if (request instanceof XmlRequestEntity && xmlModifier != null) {
                xmlModifier.accept((XmlRequestEntity) request);
            } else if (request instanceof SoapRequestEntity && soapModifier != null) {
                soapModifier.accept((SoapRequestEntity) request);
            } else if (request instanceof JdbcRequestEntity && jdbcModifier != null) {
                jdbcModifier.accept((JdbcRequestEntity) request);
            }
            
            // Process the request with the appropriate component
            Result<ThreadGroupChild> result = testSystem.processRequest(request);
            if (result.isSuccess()) {
                samplers.add(result.getValue());
            } else {
                logger.error("Failed to process request: {}", result.getException().getMessage());
                throw new TestExecutionException(ErrorCode.TEST_EXECUTION_ERROR, 
                        "Failed to process request", result.getException());
            }
        }
        
        return samplers.toArray(new ThreadGroupChild[0]);
    }
    
    /**
     * Creates the directories for storing JTL and HTML results.
     * 
     * <p>This method is now deprecated in favor of createResultsDirectories which
     * handles both JTL and HTML report directories.</p>
     * 
     * @param protocol Protocol name used for directory naming
     * @return Path to the JTL file where results will be stored
     * @throws IOException If directory creation fails
     * @deprecated Use {@link #createResultsDirectories(String)} instead
     */
    @Deprecated
    private Path createResultsDirectory(String protocol) throws IOException {
        // Use the same timestamp and unique ID as the log configuration
        String directoryName = protocol + "_" + JMeterLogConfiguration.getRunDirectoryName();
        
        // Create the directory
        Path resultsDir = Paths.get("target", "jtl-results", directoryName);
        Files.createDirectories(resultsDir);
        
        // Store the path in the result paths map
        resultPaths.put(protocol, resultsDir);
        
        // Return the path to the JTL file
        return resultsDir.resolve("results.jtl");
    }
    
    /**
     * Creates the directories for storing JTL and HTML results.
     * 
     * <p>This method creates both JTL result directories for raw data and HTML report
     * directories for human-readable reports, using the same naming pattern for consistency.</p>
     * 
     * @param protocol Protocol name used for directory naming
     * @return ResultsDirectories object containing paths to both JTL and HTML directories
     * @throws IOException If directory creation fails
     */
    private ResultsDirectories createResultsDirectories(String protocol) throws IOException {
        // Use the same timestamp and unique ID as the log configuration
        String directoryName = protocol + "_" + JMeterLogConfiguration.getRunDirectoryName();
        
        // Create the JTL results directory
        Path jtlDir = Paths.get("target", "jtl-results", directoryName);
        Files.createDirectories(jtlDir);
        Path jtlPath = jtlDir.resolve("results.jtl");
        
        // Create the HTML reports directory
        Path htmlDir = Paths.get("target", "html-reports", directoryName);
        Files.createDirectories(htmlDir);
        
        // Store the paths in the maps
        resultPaths.put(protocol, jtlDir);
        htmlReportPaths.put(protocol, htmlDir);
        
        return new ResultsDirectories(jtlPath, htmlDir);
    }
    
    /**
     * Gets the path where test results are stored for a specific protocol.
     * 
     * <p>If no tests have been run for the specified protocol, this method returns null.</p>
     * 
     * @param protocol The protocol name
     * @return The path to the results directory, or null if none exists
     */
    public Path getResultsPath(String protocol) {
        return resultPaths.get(protocol);
    }
    
    /**
     * Gets the path where HTML reports are stored for a specific protocol.
     * 
     * <p>If no tests have been run for the specified protocol, this method returns null.</p>
     * 
     * @param protocol The protocol name
     * @return The path to the HTML reports directory, or null if none exists
     */
    public Path getHtmlReportPath(String protocol) {
        return htmlReportPaths.get(protocol);
    }
    
    /**
     * Simple class to hold both JTL and HTML results paths.
     */
    private static class ResultsDirectories {
        public final Path jtlPath;
        public final Path htmlPath;
        
        public ResultsDirectories(Path jtlPath, Path htmlPath) {
            this.jtlPath = jtlPath;
            this.htmlPath = htmlPath;
        }
    }
}
