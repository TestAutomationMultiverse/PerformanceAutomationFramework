package io.perftest.engine;

import static us.abstracta.jmeter.javadsl.JmeterDsl.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.abstracta.jmeter.javadsl.core.listeners.HtmlReporter;

import io.perftest.components.graphql.GraphQLComponent;
import io.perftest.components.http.HttpComponent;
import io.perftest.components.jdbc.JdbcComponent;
import io.perftest.components.soap.SoapComponent;
import io.perftest.components.xml.XmlComponent;
import io.perftest.entities.request.GraphQLRequestEntity;
import io.perftest.entities.request.HttpRequestEntity;
import io.perftest.entities.request.JdbcRequestEntity;
import io.perftest.entities.request.RequestEntity;
import io.perftest.entities.request.SoapRequestEntity;
import io.perftest.entities.request.XmlRequestEntity;
import io.perftest.exception.ErrorCode;
import io.perftest.exception.ErrorHandler;
import io.perftest.exception.Result;
import io.perftest.exception.TestExecutionException;
import io.perftest.systems.TestSystem;
import io.perftest.util.JMeterLogConfiguration;
import us.abstracta.jmeter.javadsl.core.DslTestPlan;
import us.abstracta.jmeter.javadsl.core.TestPlanStats;
import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup;
import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup.ThreadGroupChild;

/**
 * The TestEngine is the main orchestrator for performance test execution.
 * 
 * <p>This class provides a high-level API for configuring and executing performance tests
 * using the JMeter DSL. It serves as the integration point between the ECS architecture
 * and the underlying JMeter test execution engine.</p>
 * 
 * <p>TestEngine is responsible for:</p>
 * <ul>
 *     <li>Managing test configuration (threads, iterations, ramp-up time)</li>
 *     <li>Registering components for different protocol handlers</li>
 *     <li>Coordinating the request processing pipeline</li>
 *     <li>Executing the test and collecting results</li>
 *     <li>Managing test result files and directories</li>
 * </ul>
 * 
 * <p>Example usage:</p>
 * <pre>{@code
 * TestEngine engine = new TestEngine();
 * engine.setThreads(10)
 *       .setIterations(100)
 *       .setRampUp(Duration.ofSeconds(30));
 *       
 * HttpRequestEntity request = new HttpRequestEntity()
 *       .setUrl("https://example.com/api")
 *       .setMethod("GET");
 *       
 * engine.addRequest(request);
 * TestPlanStats stats = engine.runTest();
 * }</pre>
 */
public class TestEngine {
    private static final Logger logger = LoggerFactory.getLogger(TestEngine.class);
    
    private final TestSystem testSystem;
    private final List<RequestEntity> requests;
    private final Map<String, Path> resultPaths;
    private final Map<String, Path> htmlReportPaths;
    private final Map<String, Path> unifiedReportPaths;
    
    private int threads = 1;
    private int iterations = 1;
    private Duration rampUp = Duration.ofSeconds(0);
    private boolean initialized = false;
    private String protocolName = "default";
    private String testPlanName = "Test Plan";
    
    // Modifiers for different request types
    private Consumer<HttpRequestEntity> httpModifier;
    private Consumer<GraphQLRequestEntity> graphqlModifier;
    private Consumer<XmlRequestEntity> xmlModifier;
    private Consumer<SoapRequestEntity> soapModifier;
    private Consumer<JdbcRequestEntity> jdbcModifier;
    
    /**
     * Creates a new TestEngine instance with default TestSystem.
     * 
     * <p>The constructor initializes a TestSystem and registers default components
     * for HTTP, GraphQL, XML, SOAP, and JDBC protocols.</p>
     */
    public TestEngine() {
        this(new TestSystem());
    }
    
    /**
     * Creates a new TestEngine instance with a provided TestSystem.
     * 
     * <p>This constructor allows for dependency injection of a TestSystem instance.
     * It will reuse the provided TestSystem without registering additional components.</p>
     * 
     * <p>This constructor creates a new TestSystem internally to avoid exposing internal representation.
     * Components from the provided TestSystem are not copied - we simply use it to check if we need
     * to register default components.</p>
     * 
     * @param testSystem The TestSystem to use
     */
    public TestEngine(TestSystem testSystem) {
        ErrorHandler.validateNotNull(testSystem, ErrorCode.GENERAL_ERROR, "TestSystem cannot be null");
        
        // Create a new TestSystem to avoid storing the externally provided one directly
        this.testSystem = new TestSystem();
        this.requests = new ArrayList<>();
        this.resultPaths = new HashMap<>();
        this.htmlReportPaths = new HashMap<>();
        this.unifiedReportPaths = new HashMap<>();
        
        // Register default components if original TestSystem is empty
        if (testSystem.getComponentCount() == 0) {
            registerDefaultComponents();
        } else {
            // Since we can't easily copy components from the provided TestSystem,
            // we register default components in our new instance
            registerDefaultComponents();
            logger.warn("Created new TestSystem instance with default components. Custom components in provided TestSystem are not copied.");
        }
    }
    
    /**
     * Registers the default components for various protocols.
     * 
     * <p>This method is called during TestEngine initialization to set up the
     * standard protocol handlers. It registers components for HTTP, GraphQL,
     * XML, SOAP, and JDBC protocols.</p>
     */
    private void registerDefaultComponents() {
        // Register HTTP component
        testSystem.addComponent(HttpRequestEntity.class, new HttpComponent());
        
        // Register GraphQL component
        testSystem.addComponent(GraphQLRequestEntity.class, new GraphQLComponent());
        
        // Register XML component
        testSystem.addComponent(XmlRequestEntity.class, new XmlComponent());
        
        // Register SOAP component
        testSystem.addComponent(SoapRequestEntity.class, new SoapComponent());
        
        // Register JDBC component
        testSystem.addComponent(JdbcRequestEntity.class, new JdbcComponent());
        
        initialized = true;
    }
    
    /**
     * Set the number of threads (virtual users) for the test.
     * 
     * <p>This sets the number of concurrent threads that will execute the test plan.
     * Each thread will execute the test iterations, simulating a virtual user.</p>
     * 
     * @param threads Number of threads (virtual users)
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setThreads(int threads) {
        this.threads = threads;
        return this;
    }
    
    /**
     * Get the number of threads configured for the test.
     * 
     * @return Number of threads (virtual users)
     */
    public int getThreads() {
        return threads;
    }
    
    /**
     * Set the number of iterations for the test.
     * 
     * <p>This sets the number of times each thread will execute the test samplers.
     * The total number of requests will be threads * iterations * number of samplers.</p>
     * 
     * @param iterations Number of iterations per thread
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setIterations(int iterations) {
        this.iterations = iterations;
        return this;
    }
    
    /**
     * Get the number of iterations configured for the test.
     * 
     * @return Number of iterations per thread
     */
    public int getIterations() {
        return iterations;
    }
    
    /**
     * Set the ramp-up period for the test.
     * 
     * <p>This sets the time period over which JMeter will start all threads.
     * For example, if you have 100 threads and a ramp-up period of 50 seconds,
     * then JMeter will take 50 seconds to start all 100 threads, with each thread
     * starting 0.5 seconds after the previous thread.</p>
     * 
     * @param rampUp The ramp-up period as a Duration
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setRampUp(Duration rampUp) {
        this.rampUp = rampUp;
        return this;
    }
    
    /**
     * Get the ramp-up period configured for the test.
     * 
     * @return The ramp-up period as a Duration
     */
    public Duration getRampUp() {
        return rampUp;
    }
    
    /**
     * Set the protocol name for reporting purposes.
     * 
     * <p>This name is used in log files and results directories to identify
     * the protocol being tested (e.g., "http", "graphql", "jdbc", etc.).</p>
     * 
     * @param protocolName The protocol name
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setProtocolName(String protocolName) {
        this.protocolName = protocolName;
        return this;
    }
    
    /**
     * Get the protocol name configured for reporting.
     * 
     * @return The protocol name
     */
    public String getProtocolName() {
        return protocolName;
    }
    
    /**
     * Set the test plan name.
     * 
     * <p>This name is used in JMeter reports to identify the test plan.
     * It's primarily for documentation purposes.</p>
     * 
     * @param testPlanName The test plan name
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setTestPlanName(String testPlanName) {
        this.testPlanName = testPlanName;
        return this;
    }
    
    /**
     * Get the test plan name.
     * 
     * @return The test plan name
     */
    public String getTestPlanName() {
        return testPlanName;
    }
    
    /**
     * Add a request to the test plan.
     * 
     * <p>The request will be processed by the appropriate component based on its type
     * when the test is executed.</p>
     * 
     * @param request The RequestEntity to add
     * @return This TestEngine instance for method chaining
     */
    public TestEngine addRequest(RequestEntity request) {
        requests.add(request);
        return this;
    }
    
    /**
     * Set a modifier function for HTTP requests.
     * 
     * <p>This modifier will be applied to each HttpRequestEntity before it's processed
     * by the HttpComponent. It can be used to add common headers, query parameters,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies HttpRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setHttpRequestModifier(Consumer<HttpRequestEntity> modifier) {
        this.httpModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for GraphQL requests.
     * 
     * <p>This modifier will be applied to each GraphQLRequestEntity before it's processed
     * by the GraphQLComponent. It can be used to add common headers, variables,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies GraphQLRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setGraphQLRequestModifier(Consumer<GraphQLRequestEntity> modifier) {
        this.graphqlModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for XML requests.
     * 
     * <p>This modifier will be applied to each XmlRequestEntity before it's processed
     * by the XmlComponent. It can be used to add common headers, XML attributes,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies XmlRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setXmlRequestModifier(Consumer<XmlRequestEntity> modifier) {
        this.xmlModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for SOAP requests.
     * 
     * <p>This modifier will be applied to each SoapRequestEntity before it's processed
     * by the SoapComponent. It can be used to add common headers, SOAP actions,
     * or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies SoapRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setSoapRequestModifier(Consumer<SoapRequestEntity> modifier) {
        this.soapModifier = modifier;
        return this;
    }
    
    /**
     * Set a modifier function for JDBC requests.
     * 
     * <p>This modifier will be applied to each JdbcRequestEntity before it's processed
     * by the JdbcComponent. It can be used to add common query parameters,
     * connection pool settings, or other request modifications.</p>
     * 
     * @param modifier A Consumer function that modifies JdbcRequestEntity instances
     * @return This TestEngine instance for method chaining
     */
    public TestEngine setJdbcRequestModifier(Consumer<JdbcRequestEntity> modifier) {
        this.jdbcModifier = modifier;
        return this;
    }
    
    /**
     * Run the test without additional configuration.
     * 
     * <p>This method is an alias for runTest() to maintain compatibility with 
     * older code. It simply delegates to the runTest() method.</p>
     * 
     * @return TestPlanStats containing the results of the test execution
     * @throws IOException If there's an error creating result directories
     * @throws TestExecutionException If an error occurs during test execution
     */
    public TestPlanStats run() throws IOException {
        return runTest();
    }
    
    /**
     * Execute the test plan with all configured requests and settings.
     * 
     * <p>This method processes all requests added to the TestEngine, generating
     * JMeter samplers, configuring the test execution, and running the test.</p>
     * 
     * <p>It handles setting up the result directories, configuring logging,
     * creating the JMeter test plan, and returning the test statistics.</p>
     * 
     * @return TestPlanStats containing the results of the test execution
     * @throws IOException If there's an error creating result directories
     * @throws TestExecutionException If an error occurs during test setup or execution
     */
    public TestPlanStats runTest() throws IOException {
        if (requests.isEmpty()) {
            throw new TestExecutionException(ErrorCode.TEST_EXECUTION_ERROR, "No requests added to test plan");
        }
        
        logger.info("Starting test execution with {} threads, {} iterations, {} ramp-up",
                threads, iterations, rampUp);
                
        // Create unified results directories
        ResultsDirectories resultDirs = createResultsDirectories(protocolName);
        Path jtlPath = resultDirs.jtlPath;
        Path htmlPath = resultDirs.htmlPath;
        Path unifiedDir = resultDirs.unifiedDir;
        
        // Configure JMeter logging for this specific test execution to use the unified directory
        String testLogFile = JMeterLogConfiguration.configureLoggingToDirectory(protocolName, unifiedDir.toString());
        logger.info("JMeter logs will be written to: {}", testLogFile);
        
        logger.info("Test results will be written to: {}", jtlPath);
        logger.info("HTML reports will be generated at: {}", htmlPath);
        logger.info("All test artifacts will be stored in: {}", unifiedDir);
        
        // Create thread group for the test with ThreadGroupChild[] samplers
        ThreadGroupChild[] samplers = generateSamplers();
        BaseThreadGroup threadGroup = threadGroup(threads, iterations, samplers);
        
        // Create the test plan with both JTL writer and HTML reporter
        DslTestPlan testPlan = testPlan(
                threadGroup, 
                jtlWriter(jtlPath.toString()),
                htmlReporter(htmlPath.toString())
        );
        
        try {
            logger.info("Executing test plan...");
            TestPlanStats stats = testPlan.run();
            
            logger.info("Test execution completed successfully");
            logger.info("Total requests executed: {}", stats.overall().samplesCount());
            logger.info("Total errors: {}", stats.overall().errorsCount());
            logger.info("Average response time: {} ms", stats.overall().sampleTime().mean());
            
            return stats;
        } catch (IOException e) {
            logger.error("Error executing test plan", e);
            throw new TestExecutionException(ErrorCode.TEST_EXECUTION_ERROR, 
                    "Error executing test plan: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generate JMeter samplers for the test plan based on the added requests.
     * 
     * <p>This method processes all added requests, converting them to JMeter samplers
     * using the appropriate component for each request type.</p>
     * 
     * @return Array of ThreadGroupChild objects representing the JMeter samplers
     */
    private ThreadGroupChild[] generateSamplers() {
        List<ThreadGroupChild> samplers = new ArrayList<>();
        
        for (RequestEntity request : requests) {
            if (request instanceof HttpRequestEntity) {
                HttpRequestEntity httpRequest = (HttpRequestEntity) request;
                
                // Apply HTTP request modifier if specified
                if (httpModifier != null) {
                    httpModifier.accept(httpRequest);
                }
                
                // Get the HTTP component
                HttpComponent component = (HttpComponent) testSystem.getComponent(HttpRequestEntity.class);
                if (component != null) {
                    // Process the request entity and add sampler to the list
                    Result<ThreadGroupChild> result = component.process(httpRequest);
                    if (result.isSuccess()) {
                        samplers.add(result.getValue());
                    } else {
                        logger.error("Error processing HTTP request: {}", result.getErrorMessage());
                    }
                }
            } else if (request instanceof GraphQLRequestEntity) {
                GraphQLRequestEntity graphQLRequest = (GraphQLRequestEntity) request;
                
                // Apply GraphQL request modifier if specified
                if (graphqlModifier != null) {
                    graphqlModifier.accept(graphQLRequest);
                }
                
                // Get the GraphQL component
                GraphQLComponent component = (GraphQLComponent) testSystem.getComponent(GraphQLRequestEntity.class);
                if (component != null) {
                    // Process the request entity and add sampler to the list
                    Result<ThreadGroupChild> result = component.process(graphQLRequest);
                    if (result.isSuccess()) {
                        samplers.add(result.getValue());
                    } else {
                        logger.error("Error processing GraphQL request: {}", result.getErrorMessage());
                    }
                }
            } else if (request instanceof XmlRequestEntity) {
                XmlRequestEntity xmlRequest = (XmlRequestEntity) request;
                
                // Apply XML request modifier if specified
                if (xmlModifier != null) {
                    xmlModifier.accept(xmlRequest);
                }
                
                // Get the XML component
                XmlComponent component = (XmlComponent) testSystem.getComponent(XmlRequestEntity.class);
                if (component != null) {
                    // Process the request entity and add sampler to the list
                    Result<ThreadGroupChild> result = component.process(xmlRequest);
                    if (result.isSuccess()) {
                        samplers.add(result.getValue());
                    } else {
                        logger.error("Error processing XML request: {}", result.getErrorMessage());
                    }
                }
            } else if (request instanceof SoapRequestEntity) {
                SoapRequestEntity soapRequest = (SoapRequestEntity) request;
                
                // Apply SOAP request modifier if specified
                if (soapModifier != null) {
                    soapModifier.accept(soapRequest);
                }
                
                // Get the SOAP component
                SoapComponent component = (SoapComponent) testSystem.getComponent(SoapRequestEntity.class);
                if (component != null) {
                    // Process the request entity and add sampler to the list
                    Result<ThreadGroupChild> result = component.process(soapRequest);
                    if (result.isSuccess()) {
                        samplers.add(result.getValue());
                    } else {
                        logger.error("Error processing SOAP request: {}", result.getErrorMessage());
                    }
                }
            } else if (request instanceof JdbcRequestEntity) {
                JdbcRequestEntity jdbcRequest = (JdbcRequestEntity) request;
                
                // Apply JDBC request modifier if specified
                if (jdbcModifier != null) {
                    jdbcModifier.accept(jdbcRequest);
                }
                
                // Get the JDBC component
                JdbcComponent component = (JdbcComponent) testSystem.getComponent(JdbcRequestEntity.class);
                if (component != null) {
                    // Process the request entity and add sampler to the list
                    Result<ThreadGroupChild> result = component.process(jdbcRequest);
                    if (result.isSuccess()) {
                        samplers.add(result.getValue());
                    } else {
                        logger.error("Error processing JDBC request: {}", result.getErrorMessage());
                    }
                }
            }
        }
        
        return samplers.toArray(new ThreadGroupChild[0]);
    }
    
    /**
     * Create directories for test results and HTML reports.
     * 
     * <p>This method creates the necessary directories for storing test results,
     * including JTL files and HTML reports. It uses a standardized naming pattern
     * to organize results by protocol and timestamp.</p>
     * 
     * @param protocol The protocol name for which to create directories
     * @return A ResultsDirectories object containing the paths
     * @throws IOException If there's an error creating directories
     */
    private ResultsDirectories createResultsDirectories(String protocol) throws IOException {
        // Get timestamp for unique directory names
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String uniqueId = UUID.randomUUID().toString().substring(0, 8);
        
        // Create a target directory if it doesn't exist
        Path baseDir = Paths.get("target");
        if (!Files.exists(baseDir)) {
            Files.createDirectories(baseDir);
        }
        
        // Create unified directory structure for all report files
        Path unifiedReportsDir = baseDir.resolve("unified-reports");
        if (!Files.exists(unifiedReportsDir)) {
            Files.createDirectories(unifiedReportsDir);
        }
        
        // Create protocol-specific directory with timestamp and unique ID
        String reportDirName = String.format("%s_%s_%s", protocol, timestamp, uniqueId);
        Path reportDir = unifiedReportsDir.resolve(reportDirName);
        if (!Files.exists(reportDir)) {
            Files.createDirectories(reportDir);
        }
        
        // Create a unique JTL file path within the unified directory
        Path jtlPath = reportDir.resolve(String.format("%s.jtl", protocol));
        
        // HTML reports will be in a subdirectory of the unified directory
        Path htmlPath = reportDir.resolve("html");
        if (!Files.exists(htmlPath)) {
            Files.createDirectories(htmlPath);
        }
        
        // Store the paths for later reference
        resultPaths.put(protocol, jtlPath);
        htmlReportPaths.put(protocol, htmlPath);
        unifiedReportPaths.put(protocol, reportDir);
        
        // Also store the unified directory for reference
        System.setProperty("perftest.current.report.dir", reportDir.toString());
        
        return new ResultsDirectories(jtlPath, htmlPath, reportDir);
    }
    
    /**
     * Get the path to the JTL file for a specific protocol.
     * 
     * <p>This method returns the path to the JTL file containing the test results
     * for the specified protocol. It uses the path stored during test execution.</p>
     * 
     * @param protocol The protocol for which to get the JTL file path
     * @return The path to the JTL file, or null if not available
     */
    public Path getResultsPath(String protocol) {
        return resultPaths.get(protocol);
    }
    
    /**
     * Get the path to the HTML report directory for a specific protocol.
     * 
     * <p>This method returns the path to the directory containing the HTML reports
     * for the specified protocol. It uses the path stored during test execution.</p>
     * 
     * @param protocol The protocol for which to get the HTML report path
     * @return The path to the HTML report directory, or null if not available
     */
    public Path getHtmlReportPath(String protocol) {
        return htmlReportPaths.get(protocol);
    }
    
    /**
     * Get the path to the unified report directory for a specific protocol.
     * 
     * <p>This method returns the path to the unified directory containing all reports
     * (JTL, HTML, logs) for the specified protocol.</p>
     * 
     * @param protocol The protocol for which to get the unified report directory
     * @return The path to the unified report directory, or null if not available
     */
    public Path getUnifiedReportPath(String protocol) {
        return unifiedReportPaths.get(protocol);
    }
    
    /**
     * Helper class to store paths to results directories.
     */
    private static class ResultsDirectories {
        final Path jtlPath;
        final Path htmlPath;
        final Path unifiedDir;
        
        ResultsDirectories(Path jtlPath, Path htmlPath, Path unifiedDir) {
            this.jtlPath = jtlPath;
            this.htmlPath = htmlPath;
            this.unifiedDir = unifiedDir;
        }
    }
}
