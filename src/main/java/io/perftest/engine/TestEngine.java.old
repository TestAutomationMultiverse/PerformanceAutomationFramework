package io.perftest.engine;

import java.io.IOException;
import io.perftest.components.jdbc.JdbcComponent;
import io.perftest.components.http.HttpComponent;
import io.perftest.components.graphql.GraphQLComponent;
import io.perftest.components.soap.SoapComponent;
import io.perftest.components.xml.XmlComponent;
import io.perftest.systems.TestSystem;
import io.perftest.entities.request.GraphQLRequestEntity;
import io.perftest.entities.request.HttpRequestEntity;
import io.perftest.entities.request.JdbcRequestEntity;
import io.perftest.entities.request.RequestEntity;
import io.perftest.entities.request.SoapRequestEntity;
import io.perftest.entities.request.XmlRequestEntity;
import io.perftest.exception.ErrorCode;
import io.perftest.exception.ErrorHandler;
import io.perftest.exception.PerfTestException;
import io.perftest.exception.Result;
import io.perftest.exception.TestExecutionException;
import io.perftest.util.JMeterLogConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.abstracta.jmeter.javadsl.core.DslTestPlan;
import us.abstracta.jmeter.javadsl.core.TestPlanStats;
import us.abstracta.jmeter.javadsl.core.listeners.HtmlReporter;
import us.abstracta.jmeter.javadsl.core.listeners.JtlWriter;
import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup;
import us.abstracta.jmeter.javadsl.core.threadgroups.DslDefaultThreadGroup;
import us.abstracta.jmeter.javadsl.prometheus.DslPrometheusListener;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.UUID;
import java.util.function.Consumer;

import static us.abstracta.jmeter.javadsl.JmeterDsl.*;

/**
 * Test engine for running performance tests
 */
public class TestEngine {
    private static final Logger logger = LoggerFactory.getLogger(TestEngine.class);
    
    // Static initialization block to configure JMeter logging
    static {
        // Ensure JMeter logs are configured even when using static methods
        JMeterLogConfiguration.configureJMeterLogs();
    }
    
    private final TestSystem testSystem;
    private final List<RequestEntity> requests = new ArrayList<>();
    private int threads = 1;
    private int iterations = 1;
    private Duration rampUp = Duration.ofSeconds(1);
    private Consumer<HttpRequestEntity> httpModifier;
    private Consumer<GraphQLRequestEntity> graphqlModifier;
    private Consumer<XmlRequestEntity> xmlModifier;
    private Consumer<SoapRequestEntity> soapModifier;
    private Consumer<JdbcRequestEntity> jdbcModifier;
    private String testPlanName = "Performance Test";
    private boolean shouldGenerateReports = true;
    private String protocolName = "default";
    
    /**
     * Create a new test engine with default TestSystem
     */
    public TestEngine() {
        this.testSystem = new TestSystem();
        
        // Configure JMeter logging to target directory
        JMeterLogConfiguration.configureJMeterLogs();
        
        // Register default components
        this.testSystem.addComponent(HttpRequestEntity.class, new HttpComponent());
        this.testSystem.addComponent(GraphQLRequestEntity.class, new GraphQLComponent());
        this.testSystem.addComponent(XmlRequestEntity.class, new XmlComponent());
        this.testSystem.addComponent(SoapRequestEntity.class, new SoapComponent());
        this.testSystem.addComponent(JdbcRequestEntity.class, new JdbcComponent());
    }
    
    /**
     * Create a new test engine
     * 
     * @param testSystem The test system to use for processing requests
     */
    public TestEngine(TestSystem testSystem) {
        ErrorHandler.validateNotNull(testSystem, ErrorCode.TEST_SETUP_ERROR, "TestSystem cannot be null");
        this.testSystem = testSystem;
    }
    
    /**
     * Add a request to the test plan
     * 
     * @param request The request to add
     * @throws PerfTestException If the request is null
     */
    public void addRequest(RequestEntity request) {
        ErrorHandler.validateNotNull(request, ErrorCode.TEST_SETUP_ERROR, "Request cannot be null");
        logger.info("Adding request to test plan: {}", request.getClass().getSimpleName());
        requests.add(request);
                protocolName = "soap";
            } else if (request instanceof XmlRequestEntity) {
                protocolName = "xml";
            } else if (request instanceof JdbcRequestEntity) {
                protocolName = "jdbc";
            }
        }
    }
    
    /**
     * Set the protocol name manually
     * 
     * @param protocolName Protocol name
     */
    public void setProtocolName(String protocolName) {
        ErrorHandler.validateNotNull(protocolName, ErrorCode.TEST_SETUP_ERROR, "Protocol name cannot be null");
        this.protocolName = protocolName;
    }
    
    /**
     * Get the current protocol name
     * 
     * @return Protocol name
     */
    public String getProtocolName() {
        return protocolName;
    }
    
    /**
     * Set the number of threads (virtual users) for the test
     * 
     * @param threads Number of threads
     * @throws PerfTestException If threads is less than 1
     */
    public void setThreads(int threads) {
        ErrorHandler.validate(threads > 0, ErrorCode.TEST_SETUP_ERROR, "Threads must be greater than 0");
        this.threads = threads;
    }
    
    /**
     * Set the number of iterations for the test
     * 
     * @param iterations Number of iterations
     * @throws PerfTestException If iterations is less than 1
     */
    public void setIterations(int iterations) {
        ErrorHandler.validate(iterations > 0, ErrorCode.TEST_SETUP_ERROR, "Iterations must be greater than 0");
        this.iterations = iterations;
    }
    
    /**
     * Set the ramp-up period for the test
     * 
     * @param rampUp Ramp-up duration
     * @throws PerfTestException If rampUp is null
     */
    public void setRampUp(Duration rampUp) {
        ErrorHandler.validateNotNull(rampUp, ErrorCode.TEST_SETUP_ERROR, "Ramp-up duration cannot be null");
        this.rampUp = rampUp;
    }
    
    /**
     * Set a modifier function for HTTP requests
     * 
     * @param httpModifier HTTP request modifier function
     */
    public void setHttpModifier(Consumer<HttpRequestEntity> httpModifier) {
        this.httpModifier = httpModifier;
    }
    
    /**
     * Set a modifier function for GraphQL requests
     * 
     * @param graphqlModifier GraphQL request modifier function
     */
    public void setGraphqlModifier(Consumer<GraphQLRequestEntity> graphqlModifier) {
        this.graphqlModifier = graphqlModifier;
    }
    
    /**
     * Set a modifier function for XML requests
     * 
     * @param xmlModifier XML request modifier function
     */
    public void setXmlModifier(Consumer<XmlRequestEntity> xmlModifier) {
        this.xmlModifier = xmlModifier;
    }
    
    /**
     * Set a modifier function for SOAP requests
     * 
     * @param soapModifier SOAP request modifier function
     */
    public void setSoapModifier(Consumer<SoapRequestEntity> soapModifier) {
        this.soapModifier = soapModifier;
    }
    
    /**
     * Set a modifier function for JDBC requests
     * 
     * @param jdbcModifier JDBC request modifier function
     */
    public void setJdbcModifier(Consumer<JdbcRequestEntity> jdbcModifier) {
        this.jdbcModifier = jdbcModifier;
    }
    
    /**
     * Set the test plan name
     * 
     * @param testPlanName Test plan name
     * @throws PerfTestException If testPlanName is null
     */
    public void setTestPlanName(String testPlanName) {
        ErrorHandler.validateNotNull(testPlanName, ErrorCode.TEST_SETUP_ERROR, "Test plan name cannot be null");
        this.testPlanName = testPlanName;
    }
    
    /**
     * Set whether to generate reports
     * 
     * @param shouldGenerateReports True to generate reports
     */
    public void setShouldGenerateReports(boolean shouldGenerateReports) {
        this.shouldGenerateReports = shouldGenerateReports;
    }

    /**
     * Create directories for test results
     * 
     * @param protocolName Protocol name for the report
     * @return Path to the test results file
     * @throws PerfTestException If an error occurs creating the directories
     */
    private Path createResultsDirectory(String protocolName) {
        try {
            // Create directory structure for HTML reports
            Path htmlReportDir = Paths.get("target", "html-reports", protocolName);
            Files.createDirectories(htmlReportDir);
            
            // Create directory for JTL files
            Path jtlDir = Paths.get("target", "jtl-results");
            Files.createDirectories(jtlDir);
            
            // Create test-specific directory with timestamp and UUID
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss"));
            String uniqueId = UUID.randomUUID().toString();
            Path testSpecificDir = jtlDir.resolve(protocolName + "-test-results.jtl")
                    .resolve(timestamp + " " + uniqueId + ".jtl");
            Files.createDirectories(testSpecificDir.getParent());
            
            return testSpecificDir;
        } catch (IOException e) {
            throw new PerfTestException(ErrorCode.REPORTING_ERROR, "Failed to create results directory", e);
        }
    }
    
    /**
     * Execute an HTTP test with the given request entity
     * 
     * @param requestEntity The HTTP request entity
     * @param threads Number of threads (users)
     * @param iterations Number of iterations per thread
     * @return Test statistics
     * @throws PerfTestException If an error occurs during test execution
     */
    public TestPlanStats executeHttpTest(HttpRequestEntity requestEntity, int threads, int iterations) throws IOException {
        ErrorHandler.validateNotNull(requestEntity, ErrorCode.TEST_EXECUTION_ERROR, "HTTP request entity cannot be null");
        ErrorHandler.validate(threads > 0, ErrorCode.TEST_EXECUTION_ERROR, "Threads must be greater than 0");
        ErrorHandler.validate(iterations > 0, ErrorCode.TEST_EXECUTION_ERROR, "Iterations must be greater than 0");
        
        logger.info("Executing HTTP test: {} with {} threads, {} iterations", 
                requestEntity.getProperty("name", "HTTP Request"), threads, iterations);
        
        // Clear previous requests
        requests.clear();
        
        // Set protocol name
        protocolName = "http";
        
        // Set thread and iteration count
        this.threads = threads;
        this.iterations = iterations;
        
        // Add the request
        addRequest(requestEntity);
        
        return ErrorHandler.executeWithIOHandling(() -> {
            // Build samplers
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            
            // Create thread group
            DslDefaultThreadGroup threadGroup = threadGroup()
                .rampTo(threads, rampUp);
            
            // Add samplers to thread group
            if (samplers.length > 0) {
                threadGroup = threadGroup.children(samplers);
            }
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            
            // Run the test with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroup,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            // Log that this is where we would generate HTML report
            logger.info("JTL file created at: {}. Use JMeter to convert to HTML report", resultsFile);
            
            return stats;
        }, ErrorCode.TEST_EXECUTION_ERROR, "Error executing HTTP test", logger);
    }
    
    /**
     * Execute a GraphQL test with the given request entity
     * 
     * @param requestEntity The GraphQL request entity
     * @param threads Number of threads (users)
     * @param iterations Number of iterations per thread
     * @return Test statistics
     * @throws PerfTestException If an error occurs during test execution
     */
    public TestPlanStats executeGraphQLTest(GraphQLRequestEntity requestEntity, int threads, int iterations) throws IOException {
        ErrorHandler.validateNotNull(requestEntity, ErrorCode.TEST_EXECUTION_ERROR, "GraphQL request entity cannot be null");
        ErrorHandler.validate(threads > 0, ErrorCode.TEST_EXECUTION_ERROR, "Threads must be greater than 0");
        ErrorHandler.validate(iterations > 0, ErrorCode.TEST_EXECUTION_ERROR, "Iterations must be greater than 0");
        
        logger.info("Executing GraphQL test: {} with {} threads, {} iterations", 
                requestEntity.getProperty("name", "GraphQL Request"), threads, iterations);
        
        // Clear previous requests
        requests.clear();
        
        // Set protocol name
        protocolName = "graphql";
        
        // Set thread and iteration count
        this.threads = threads;
        this.iterations = iterations;
        
        // Add the request
        addRequest(requestEntity);
        
        return ErrorHandler.executeWithIOHandling(() -> {
            // Build samplers
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            
            // Create thread group
            DslDefaultThreadGroup threadGroup = threadGroup()
                .rampTo(threads, rampUp);
                
            // Add samplers to thread group
            if (samplers.length > 0) {
                threadGroup = threadGroup.children(samplers);
            }
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            
            // Run the test with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroup,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            // Log that this is where we would generate HTML report
            logger.info("JTL file created at: {}. Use JMeter to convert to HTML report", resultsFile);
            
            return stats;
        }, ErrorCode.TEST_EXECUTION_ERROR, "Error executing GraphQL test", logger);
    }
    
    /**
     * Execute a SOAP test with the given request entity
     * 
     * @param requestEntity The SOAP request entity
     * @param threads Number of threads (users)
     * @param iterations Number of iterations per thread
     * @return Test statistics
     * @throws PerfTestException If an error occurs during test execution
     */
    public TestPlanStats executeSoapTest(SoapRequestEntity requestEntity, int threads, int iterations) throws IOException {
        ErrorHandler.validateNotNull(requestEntity, ErrorCode.TEST_EXECUTION_ERROR, "SOAP request entity cannot be null");
        ErrorHandler.validate(threads > 0, ErrorCode.TEST_EXECUTION_ERROR, "Threads must be greater than 0");
        ErrorHandler.validate(iterations > 0, ErrorCode.TEST_EXECUTION_ERROR, "Iterations must be greater than 0");
        
        logger.info("Executing SOAP test: {} with {} threads, {} iterations", 
                requestEntity.getProperty("name", "SOAP Request"), threads, iterations);
        
        // Clear previous requests
        requests.clear();
        
        // Set protocol name
        protocolName = "soap";
        
        // Set thread and iteration count
        this.threads = threads;
        this.iterations = iterations;
        
        // Add the request
        addRequest(requestEntity);
        
        return ErrorHandler.executeWithIOHandling(() -> {
            // Build samplers
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            
            // Create thread group
            DslDefaultThreadGroup threadGroup = threadGroup()
                .rampTo(threads, rampUp);
                
            // Add samplers to thread group
            if (samplers.length > 0) {
                threadGroup = threadGroup.children(samplers);
            }
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            // Run the test with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroup,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            // Log that this is where we would generate HTML report
            logger.info("JTL file created at: {}. Use JMeter to convert to HTML report", resultsFile);
            
            return stats;
        }, ErrorCode.TEST_EXECUTION_ERROR, "Error executing SOAP test", logger);
    }
    
    /**
     * Execute a JDBC test with the given request entity
     * 
     * @param requestEntity The JDBC request entity
     * @param threads Number of threads (users)
     * @param iterations Number of iterations per thread
     * @return Test statistics
     * @throws PerfTestException If an error occurs during test execution
     */
    public TestPlanStats executeJdbcTest(JdbcRequestEntity requestEntity, int threads, int iterations) throws IOException {
        ErrorHandler.validateNotNull(requestEntity, ErrorCode.TEST_EXECUTION_ERROR, "JDBC request entity cannot be null");
        ErrorHandler.validate(threads > 0, ErrorCode.TEST_EXECUTION_ERROR, "Threads must be greater than 0");
        ErrorHandler.validate(iterations > 0, ErrorCode.TEST_EXECUTION_ERROR, "Iterations must be greater than 0");
        
        logger.info("Executing JDBC test: {} with {} threads, {} iterations", 
                requestEntity.getProperty("name", "JDBC Request"), threads, iterations);
        
        // Clear previous requests
        requests.clear();
        
        // Set protocol name
        protocolName = "jdbc";
        
        // Set thread and iteration count
        this.threads = threads;
        this.iterations = iterations;
        
        // Add the request
        addRequest(requestEntity);
        
        return ErrorHandler.executeWithIOHandling(() -> {
            // Build samplers
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            
            // Create thread group
            DslDefaultThreadGroup threadGroup = threadGroup()
                .rampTo(threads, rampUp);
                
            // Add samplers to thread group
            if (samplers.length > 0) {
                threadGroup = threadGroup.children(samplers);
            }
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            // Run the test with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroup,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            // Log that this is where we would generate HTML report
            logger.info("JTL file created at: {}. Use JMeter to convert to HTML report", resultsFile);
            
            return stats;
        }, ErrorCode.TEST_EXECUTION_ERROR, "Error executing JDBC test", logger);
    }
    
    /**
     * Run the test plan
     * 
     * @return Test statistics
     * @throws PerfTestException If an error occurs during test execution
     */
    public TestPlanStats run() throws IOException {
        logger.info("Running test plan: {} with {} threads, {} iterations, {} ramp-up",
                testPlanName, threads, iterations, rampUp);
        
        ErrorHandler.validate(!requests.isEmpty(), ErrorCode.TEST_EXECUTION_ERROR, 
                "No requests added to test plan. Add at least one request before running the test.");
        
        return ErrorHandler.executeWithIOHandling(() -> {
            // Build samplers first
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            ErrorHandler.validate(samplers.length > 0, ErrorCode.TEST_EXECUTION_ERROR, 
                    "No samplers were built. Check that components are properly registered.");
            
            // Create thread group first
            DslDefaultThreadGroup threadGroupConfig = threadGroup()
                .rampTo(threads, rampUp);
            
            // Add samplers to thread group
            threadGroupConfig = threadGroupConfig.children(samplers);
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            // Run the test plan with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroupConfig,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            logger.info("Test plan execution completed successfully");
            logger.info("JTL file created at: {}. HTML report can be generated from this file", resultsFile);
            
            saveTestSummary(stats, resultsFile);
            
            return stats;
        }, ErrorCode.TEST_EXECUTION_ERROR, "Failed to run test plan", logger);
    }
    
    /**
     * Save a summary of the test results to a file
     * 
     * @param stats The test statistics
     * @param resultsFile The path to the results file
     */
    private void saveTestSummary(TestPlanStats stats, Path resultsFile) {
        try {
            // Create a summary file next to the JTL file
            Path summaryFile = resultsFile.resolveSibling(resultsFile.getFileName().toString() + ".summary.txt");
            
            // Write summary information to the file
            try (FileWriter writer = new FileWriter(summaryFile.toFile())) {
                writer.write("Test Plan: " + testPlanName + "\n");
                writer.write("Protocol: " + protocolName + "\n");
                writer.write("Threads: " + threads + "\n");
                writer.write("Iterations: " + iterations + "\n");
                writer.write("Ramp-up: " + rampUp + "\n");
                writer.write("\n");
                writer.write("Overall Statistics:\n");
                writer.write("- Samples Count: " + stats.overall().samplesCount() + "\n");
                writer.write("- Error Count: " + stats.overall().errorsCount() + "\n");
                
                // Error rate calculation manually since errorsRate() is not available
                double errorRate = stats.overall().samplesCount() > 0 
                    ? (double) stats.overall().errorsCount() / stats.overall().samplesCount() 
                    : 0.0;
                writer.write("- Error Rate: " + String.format("%.2f%%", errorRate * 100) + "\n");
                
                // Use mean() instead of avg()
                writer.write("- Average Response Time: " + stats.overall().sampleTime().mean() + " ms\n");
                
                // Use percentile(50) instead of perc50()
                writer.write("- Median Response Time: " + stats.overall().sampleTime().median() + " ms\n");
                writer.write("- 90th Percentile Response Time: " + stats.overall().sampleTime().perc90() + " ms\n");
                writer.write("- 95th Percentile Response Time: " + stats.overall().sampleTime().perc95() + " ms\n");
                writer.write("- 99th Percentile Response Time: " + stats.overall().sampleTime().perc99() + " ms\n");
                writer.write("- Min Response Time: " + stats.overall().sampleTime().min() + " ms\n");
                writer.write("- Max Response Time: " + stats.overall().sampleTime().max() + " ms\n");
                
                // Calculate throughput manually
                double elapsedTimeSeconds = stats.duration().toMillis() / 1000.0;
                double throughput = elapsedTimeSeconds > 0 
                    ? stats.overall().samplesCount() / elapsedTimeSeconds
                    : 0.0;
                writer.write("- Throughput: " + String.format("%.2f", throughput) + " req/s\n");
            }
            
            logger.info("Test summary saved to: {}", summaryFile);
        } catch (IOException e) {
            logger.error("Failed to save test summary: {}", e.getMessage(), e);
            // Don't throw an exception here, as it would disrupt the normal flow
        }
    }
    
    /**
     * Build JMeter samplers for all requests
     * 
     * @return Array of samplers
     * @throws PerfTestException If an error occurs building samplers
     */
    private BaseThreadGroup.ThreadGroupChild[] buildSamplers() throws IOException {
        return ErrorHandler.executeWithIOHandling(() -> {
            List<BaseThreadGroup.ThreadGroupChild> samplers = new ArrayList<>();
            
            for (RequestEntity request : requests) {
                if (request instanceof HttpRequestEntity) {
                    HttpRequestEntity httpRequest = (HttpRequestEntity) request;
                    if (httpModifier != null) {
                        httpModifier.accept(httpRequest);
                    }
                    samplers.add(testSystem.processRequest(httpRequest));
                } else if (request instanceof GraphQLRequestEntity) {
                    GraphQLRequestEntity graphQLRequest = (GraphQLRequestEntity) request;
                    if (graphqlModifier != null) {
                        graphqlModifier.accept(graphQLRequest);
                    }
                    samplers.add(testSystem.processRequest(graphQLRequest));
                } else if (request instanceof SoapRequestEntity) {
                    SoapRequestEntity soapRequest = (SoapRequestEntity) request;
                    if (soapModifier != null) {
                        soapModifier.accept(soapRequest);
                    }
                    samplers.add(testSystem.processRequest(soapRequest));
                } else if (request instanceof XmlRequestEntity) {
                    XmlRequestEntity xmlRequest = (XmlRequestEntity) request;
                    if (xmlModifier != null) {
                        xmlModifier.accept(xmlRequest);
                    }
                    samplers.add(testSystem.processRequest(xmlRequest));
                } else if (request instanceof JdbcRequestEntity) {
                    JdbcRequestEntity jdbcRequest = (JdbcRequestEntity) request;
                    if (jdbcModifier != null) {
                        jdbcModifier.accept(jdbcRequest);
                    }
                    samplers.add(testSystem.processRequest(jdbcRequest));
                }
            }
            
            return samplers.toArray(new BaseThreadGroup.ThreadGroupChild[0]);
        }, ErrorCode.TEST_EXECUTION_ERROR, "Failed to build samplers", logger);
    }
    
    /**
     * Add a post-processor to run after each sampler
     * This will be implemented in a future version
     * 
     * @param postProcessor The post-processor to add
     */
    public void addPostProcessor(BaseThreadGroup.ThreadGroupChild postProcessor) {
        ErrorHandler.validateNotNull(postProcessor, ErrorCode.TEST_SETUP_ERROR, "Post-processor cannot be null");
        // To be implemented
        logger.warn("addPostProcessor is not yet implemented");
    }
    
    /**
     * Add a listener to collect test results
     * This will be implemented in a future version
     * 
     * @param listener The listener to add
     */
    public void addListener(BaseThreadGroup.ThreadGroupChild listener) {
        ErrorHandler.validateNotNull(listener, ErrorCode.TEST_SETUP_ERROR, "Listener cannot be null");
        // To be implemented
        logger.warn("addListener is not yet implemented");
    }
    
    /**
     * Get a Result containing a safely created TestPlanStats
     * 
     * @return A Result containing the TestPlanStats or an error
     */
    public Result<TestPlanStats> safeRun() throws IOException {
        logger.info("Safely running test plan: {} with {} threads, {} iterations, {} ramp-up",
                testPlanName, threads, iterations, rampUp);
        
        if (requests.isEmpty()) {
            return Result.failure(ErrorCode.TEST_EXECUTION_ERROR, 
                    "No requests added to test plan. Add at least one request before running the test.");
        }
        
        try {
            // Build samplers first
            BaseThreadGroup.ThreadGroupChild[] samplers = buildSamplers();
            if (samplers.length == 0) {
                return Result.failure(ErrorCode.TEST_EXECUTION_ERROR, 
                        "No samplers were built. Check that components are properly registered.");
            }
            
            // Create thread group
            DslDefaultThreadGroup threadGroupConfig = threadGroup()
                .rampTo(threads, rampUp);
            
            // Add samplers to thread group
            threadGroupConfig = threadGroupConfig.children(samplers);
            
            // Create results directory and file
            Path resultsFile = createResultsDirectory(protocolName);
            logger.info("JTL results will be saved to: {}", resultsFile);
            
            // Create JTL writer for saving results
            JtlWriter jtlWriter = jtlWriter(resultsFile.toString());
            // Create Prometheus backend listener for real-time monitoring
            DslPrometheusListener prometheusListener = DslPrometheusListener.prometheusListener();
            logger.info("Prometheus metrics will be exposed on port 9270");
    
            // Run the test plan with JTL writer
            TestPlanStats stats = testPlan(
                    threadGroupConfig,
                    jtlWriter,
                    prometheusListener
                ).run();
            
            logger.info("Test plan execution completed successfully");
            logger.info("JTL file created at: {}. HTML report can be generated from this file", resultsFile);
            
            saveTestSummary(stats, resultsFile);
            
            return Result.success(stats);
        } catch (Exception e) {
            logger.error("Failed to run test plan: {}", e.getMessage(), e);
            if (e instanceof PerfTestException) {
                return Result.failure((PerfTestException) e);
            } else {
                return Result.failure(ErrorCode.TEST_EXECUTION_ERROR, "Failed to run test plan: " + e.getMessage(), e);
            }
        }
    }
}
